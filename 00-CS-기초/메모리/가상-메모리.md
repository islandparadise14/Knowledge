---
tags: [cs, memory, virtual-memory, os, android]
---

# 가상 메모리

## 💡 핵심 개념

**가상 메모리**는 각 프로세스에게 독립적인 메모리 공간을 제공하는 OS의 메모리 관리 기법이다. 프로세스는 실제 물리 메모리 주소가 아닌 **가상 주소**를 사용하고, OS가 이를 물리 주소로 변환(페이지 테이블)한다.

## 📌 왜 필요한가?

Android 앱은 각각 독립된 가상 메모리 공간에서 실행된다. 앱 간 메모리 격리, mmap을 이용한 Binder IPC, 메모리 부족 시 Low Memory Killer 동작을 이해하는 기반이다.

## 🔍 자세히

### 가상 메모리 구조

```
프로세스 A (가상 주소)     물리 메모리        프로세스 B (가상 주소)
┌──────────┐            ┌──────────┐     ┌──────────┐
│ 0x0000~  │──page──→   │ 물리 0x30│ ←── │ 0x0000~  │
│ 0x1000~  │──table──→  │ 물리 0x10│     │ 0x1000~  │──→ 물리 0x50
│ 0x2000~  │──mapping→  │ 물리 0x70│     │ 0x2000~  │──→ 물리 0x90
└──────────┘            └──────────┘     └──────────┘
각 프로세스는 같은 가상 주소를 사용하지만, 다른 물리 메모리에 매핑됨
```

### 페이징

메모리를 고정 크기 **페이지**(보통 4KB)로 나누어 관리한다.

- **Page Fault:** 접근한 페이지가 물리 메모리에 없을 때 → 디스크에서 로드
- **Swap:** 물리 메모리 부족 시 덜 사용하는 페이지를 디스크로 이동

### Android의 메모리 관리

```
Android는 swap 대신 다른 전략을 사용:

1. Low Memory Killer (LMK)
   물리 메모리 부족 시 우선순위 낮은 프로세스를 종료
   우선순위: Foreground > Visible > Service > Background > Empty

2. zRAM
   swap 대신 RAM 일부를 압축 영역으로 사용
   디스크 I/O 없이 메모리 확보

3. 프로세스별 Heap 제한
   앱당 사용 가능한 Heap 크기 제한 (largeHeap 옵션으로 확장 가능)
```

```xml
<!-- AndroidManifest.xml -->
<application android:largeHeap="true">
    <!-- 권장하지 않음 - 정말 필요한 경우에만 -->
</application>
```

### mmap - 파일을 메모리에 매핑

```kotlin
// mmap은 파일을 가상 메모리에 직접 매핑 → 읽기/쓰기가 메모리 접근처럼 빠름
// Android Binder IPC가 mmap으로 1회 복사를 달성
// SQLite도 내부적으로 mmap 사용 가능

val file = RandomAccessFile("data.bin", "r")
val channel = file.channel
val buffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, file.length())
// buffer를 통해 파일 내용을 메모리처럼 접근
```

## 🔗 관련 개념

- [[00-CS-기초/운영체제/프로세스-관리|프로세스 관리]]
- [[00-CS-기초/운영체제/IPC-프로세스간-통신|IPC 프로세스간 통신]]
- [[00-CS-기초/메모리/스택-vs-힙|스택 vs 힙]]

## 📚 더 보기

- [Android Memory Management](https://developer.android.com/topic/performance/memory-overview)

---

**핵심 요약:** 가상 메모리는 프로세스별 독립 주소 공간을 제공한다. Android는 swap 대신 LMK(프로세스 종료)와 zRAM(압축)으로 메모리를 관리하며, Binder IPC는 mmap으로 효율적으로 동작한다.
