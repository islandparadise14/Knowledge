---
tags: [cs, memory, alignment, padding]
---

# 메모리 정렬과 패딩

## 💡 핵심 개념

**메모리 정렬**(Alignment)은 데이터를 특정 바이트 경계에 맞춰 배치하는 것이고, **패딩**(Padding)은 정렬을 위해 삽입되는 빈 바이트이다. CPU는 정렬된 메모리 접근이 빠르기 때문에 컴파일러가 자동으로 패딩을 추가한다.

## 📌 왜 필요한가?

JVM이 대부분 처리하므로 일상적으로 신경 쓸 일은 적지만, NDK 개발이나 메모리 최적화(객체 크기 줄이기) 시 알아야 한다.

## 🔍 자세히

### JVM에서의 객체 메모리 레이아웃

```
┌──────────────────────┐
│ Object Header (12B)  │  마크 워드(8B) + 클래스 포인터(4B, 압축)
├──────────────────────┤
│ 필드 데이터           │  타입별 정렬 규칙 적용
├──────────────────────┤
│ Padding              │  8바이트 배수로 맞춤
└──────────────────────┘
```

### JVM 타입별 크기

| 타입 | 크기 | 정렬 |
|---|---|---|
| boolean / byte | 1B | 1B |
| char / short | 2B | 2B |
| int / float | 4B | 4B |
| long / double | 8B | 8B |
| 참조 (압축) | 4B | 4B |

### 필드 순서와 메모리 크기

```kotlin
// JVM은 필드를 크기 순으로 재배치할 수 있음
class Example {
    val a: Byte = 0    // 1B
    val b: Long = 0L   // 8B
    val c: Int = 0     // 4B
}

// 실제 메모리 (JVM이 최적화):
// Header(12B) + long(8B) + int(4B) + byte(1B) + padding(7B) = 32B
```

### Android에서의 실전

```kotlin
// SparseArray는 int 키를 박싱하지 않아 메모리 효율적
// HashMap<Int, String> → Integer 박싱 오버헤드
// SparseArray<String> → int 그대로 사용

val sparse = SparseArray<String>()
sparse.put(1, "one")  // int 키 (박싱 없음)

val map = HashMap<Int, String>()
map[1] = "one"  // Integer 객체 생성 (16B 오버헤드)
```

## 🔗 관련 개념

- [[00-CS-기초/메모리/스택-vs-힙|스택 vs 힙]]
- [[00-CS-기초/메모리/캐시-메모리|캐시 메모리]]
- [[00-CS-기초/JVM/JVM-구조|JVM 구조]]

## 📚 더 보기

- [JOL - Java Object Layout](https://openjdk.org/projects/code-tools/jol/)

---

**핵심 요약:** JVM은 객체를 8바이트 배수로 정렬하고 패딩을 추가한다. Android에서 SparseArray, ArrayMap 등은 박싱/패딩 오버헤드를 줄인 메모리 최적화 컬렉션이다.
