---
tags: [cs, algorithm, greedy, optimization]
---

# 그리디 (Greedy Algorithm)

## 💡 핵심 개념

**그리디 알고리즘**은 매 단계에서 현재 가장 좋아 보이는 선택(지역 최적해)을 하여 전체 최적해를 구하는 방법이다. DP와 달리 이전 선택을 번복하지 않는다. **탐욕 선택 속성**이 성립할 때만 올바른 결과를 보장한다.

## 📌 왜 필요한가?

DP보다 구현이 간단하고 빠르므로, 그리디가 적용 가능한 문제를 식별하는 능력이 중요하다. 네트워크 요청 스케줄링, 리소스 할당, LRU 캐시 등에 그리디 사고가 활용된다.

## 🔍 자세히

### 그리디 vs DP

| 특성 | 그리디 | DP |
|---|---|---|
| 접근 | 현재 최선의 선택 | 모든 경우 고려 |
| 시간 복잡도 | 보통 더 빠름 | 느릴 수 있음 |
| 정확성 | 조건 충족 시만 최적 | 항상 최적 |
| 되돌림 | 없음 | 하위 문제 재활용 |

### 대표 문제: 활동 선택 (Activity Selection)

```kotlin
// 최대한 많은 회의를 배정하기
// 전략: 끝나는 시간이 빠른 순으로 정렬 후 선택
data class Meeting(val start: Int, val end: Int)

fun maxMeetings(meetings: List<Meeting>): List<Meeting> {
    val sorted = meetings.sortedBy { it.end }
    val selected = mutableListOf<Meeting>()
    var lastEnd = 0

    for (m in sorted) {
        if (m.start >= lastEnd) {
            selected.add(m)
            lastEnd = m.end
        }
    }
    return selected
}
```

### 대표 문제: 동전 거스름돈

```kotlin
// 그리디가 동작하는 경우: 한국 화폐 (500, 100, 50, 10)
fun coinGreedy(amount: Int): Map<Int, Int> {
    val coins = listOf(500, 100, 50, 10)
    var remaining = amount
    val result = mutableMapOf<Int, Int>()
    for (coin in coins) {
        if (remaining >= coin) {
            result[coin] = remaining / coin
            remaining %= coin
        }
    }
    return result
}

// ⚠️ 주의: 동전이 [1, 3, 4]일 때 6원
// 그리디: 4+1+1 = 3개 (오답)
// DP: 3+3 = 2개 (정답)
// → 동전 단위에 따라 그리디가 실패할 수 있다!
```

### 대표 문제: 분할 배낭 (Fractional Knapsack)

```kotlin
// 물건을 쪼갤 수 있는 배낭 → 그리디 가능
data class Item(val weight: Double, val value: Double) {
    val ratio get() = value / weight  // 무게당 가치
}

fun fractionalKnapsack(items: List<Item>, capacity: Double): Double {
    val sorted = items.sortedByDescending { it.ratio }
    var remaining = capacity
    var total = 0.0

    for (item in sorted) {
        if (remaining >= item.weight) {
            total += item.value
            remaining -= item.weight
        } else {
            total += item.ratio * remaining  // 쪼개서 넣기
            break
        }
    }
    return total
}
// 0/1 배낭 (쪼갤 수 없음)은 그리디 불가 → DP 필요
```

### Android 실무 활용

```kotlin
// 1. 작업 스케줄링 - 데드라인 가까운 것 먼저
data class Task(val name: String, val deadline: Long)
fun schedule(tasks: List<Task>) = tasks.sortedBy { it.deadline }

// 2. LRU 캐시 - 가장 오래 안 쓴 것부터 제거 (그리디 전략)
val cache = object : LruCache<String, Bitmap>(maxSize) {
    override fun sizeOf(key: String, bitmap: Bitmap) = bitmap.byteCount / 1024
}

// 3. 네트워크 요청 최적화 - 작은 요청 먼저 (SJF)
fun optimizeRequests(requests: List<Request>) =
    requests.sortedBy { it.estimatedSize }

// 4. Compose 레이아웃 weight - 가용 공간 비율 분배
Row {
    Box(Modifier.weight(2f)) { /* 2/3 */ }
    Box(Modifier.weight(1f)) { /* 1/3 */ }
}
```

### 그리디 적용 판단법

1. **탐욕 선택 속성**: 지역 최적이 전역 최적을 해치지 않는가?
2. **반례 찾기**: 그리디로 최적해를 못 구하는 경우가 있는가?
3. 그리디 실패 → DP 사용

## 🔗 관련 개념

- [[00-CS-기초/알고리즘/동적-프로그래밍|동적 프로그래밍]]
- [[00-CS-기초/알고리즘/정렬-알고리즘|정렬 알고리즘]]
- [[00-CS-기초/알고리즘/시간-복잡도-Big-O|시간 복잡도 Big-O]]
- [[00-CS-기초/자료구조/힙과-우선순위-큐|힙과 우선순위 큐]]

## 📚 더 보기

- [Greedy Algorithms - GeeksforGeeks](https://www.geeksforgeeks.org/greedy-algorithms/)

---

**핵심 요약:** 그리디는 매 단계 최선을 선택하는 단순하고 빠른 기법이지만, 탐욕 선택 속성이 보장될 때만 최적해를 구할 수 있다. 그렇지 않으면 DP를 사용해야 한다.
