---
tags: [os, scheduling, cpu, android, cfs, priority]
---

# 스케줄링

## 💡 핵심 개념

**CPU 스케줄링**은 어떤 프로세스(또는 스레드)에 CPU를 할당할지 결정하는 운영체제의 핵심 기능이다. 한정된 CPU 자원을 여러 프로세스가 공정하고 효율적으로 사용하도록 관리한다. Android는 Linux의 CFS(Completely Fair Scheduler)를 기반으로 하며, UI 스레드의 응답성을 보장하기 위한 추가 정책을 적용한다.

## 📌 왜 필요한가?

Android에서 UI 스레드가 제때 스케줄링되지 않으면 ANR이 발생한다. 스케줄링 원리를 이해하면 스레드 우선순위 설정과 성능 최적화를 효과적으로 할 수 있다.

## 🔍 자세히

### 스케줄링 기준 지표

| 지표 | 설명 |
|------|------|
| CPU 이용률 | CPU가 실제로 일하는 비율 |
| 처리량 (Throughput) | 단위 시간당 완료되는 프로세스 수 |
| 대기 시간 (Waiting Time) | Ready 큐에서 기다린 총 시간 |
| 응답 시간 (Response Time) | 요청 후 첫 응답까지 시간 |
| 반환 시간 (Turnaround Time) | 제출부터 완료까지 총 시간 |

### 선점형 vs 비선점형

| 구분 | 선점형 (Preemptive) | 비선점형 (Non-preemptive) |
|------|---------------------|--------------------------|
| 동작 | OS가 강제로 CPU 회수 가능 | 프로세스가 자발적으로 반납 |
| 응답성 | 높음 | 낮음 |
| 오버헤드 | 컨텍스트 스위칭 비용 | 적음 |
| 사용 | Linux, Android, Windows | 초기 OS, 단순 임베디드 |

Android(Linux)는 **선점형 스케줄링**을 사용한다.

### 주요 스케줄링 알고리즘

**1. FCFS (First-Come, First-Served)**
```
도착 순서대로 처리. Convoy Effect 발생 가능.
P1(24ms) → P2(3ms) → P3(3ms)
평균 대기: (0 + 24 + 27) / 3 = 17ms
```

**2. SJF (Shortest Job First)**
```
실행 시간이 짧은 것부터. 평균 대기 시간 최소.
P2(3ms) → P3(3ms) → P1(24ms)
평균 대기: (0 + 3 + 6) / 3 = 3ms
```

**3. Round Robin (RR)**
```
Time Quantum(시간 할당량)만큼 돌아가며 실행.
Quantum = 4ms
P1 → P2 → P3 → P1 → P1 → P1 → ...
```

**4. Priority Scheduling**
```
우선순위가 높은 프로세스 먼저. 기아(Starvation) 문제 발생 가능.
해결책: Aging - 오래 기다린 프로세스의 우선순위를 점진적으로 높임.
```

**5. CFS (Completely Fair Scheduler) - Linux/Android 사용**

Linux 2.6.23부터 기본 스케줄러. 모든 프로세스에 **공정한** CPU 시간을 배분한다.

```
핵심 개념: vruntime (virtual runtime)
- 각 프로세스가 CPU를 사용한 가상 시간
- vruntime이 가장 작은 프로세스를 다음에 실행
- Red-Black Tree로 관리 → O(log N) 탐색

nice값이 낮으면(우선순위 높으면) vruntime이 느리게 증가
→ 더 자주 스케줄링됨
```

### Android의 스레드 우선순위

Android는 Linux의 `nice` 값과 `cgroup`을 조합해 스레드를 관리한다:

| Android 상수 | nice 값 | 용도 |
|--------------|---------|------|
| THREAD_PRIORITY_URGENT_DISPLAY | -8 | UI 렌더링 |
| THREAD_PRIORITY_DISPLAY | -4 | 디스플레이 관련 |
| THREAD_PRIORITY_DEFAULT | 0 | 기본값 (메인 스레드) |
| THREAD_PRIORITY_BACKGROUND | 10 | 백그라운드 작업 |
| THREAD_PRIORITY_LOWEST | 19 | 최저 우선순위 |

```kotlin
// 스레드 우선순위 설정
Thread {
    // 백그라운드 작업에 낮은 우선순위 부여
    android.os.Process.setThreadPriority(
        android.os.Process.THREAD_PRIORITY_BACKGROUND
    )
    // 무거운 작업 수행
    heavyComputation()
}.start()

// Coroutine에서의 우선순위 (Dispatchers가 내부적으로 관리)
viewModelScope.launch(Dispatchers.Default) {
    // Default: CPU 집약적 작업, 코어 수만큼 스레드
}

viewModelScope.launch(Dispatchers.IO) {
    // IO: I/O 작업, 최대 64개 스레드, 낮은 우선순위
}

viewModelScope.launch(Dispatchers.Main) {
    // Main: UI 작업, 높은 우선순위
}
```

### cgroup (Control Group)

Android는 Linux의 cgroup을 사용해 Foreground/Background 앱의 CPU 시간을 차등 배분한다:

```
Foreground 앱 → foreground cgroup (CPU 시간 95%)
Background 앱 → background cgroup (CPU 시간 5%)
```

앱이 백그라운드로 전환되면 모든 스레드가 background cgroup으로 이동해 CPU를 적게 받는다.

### ANR과 스케줄링

```
UI 스레드(Main Thread)가 일정 시간 내 응답하지 못하면 ANR 발생:
- Activity: 5초
- BroadcastReceiver: 10초
- Service: 20초 (foreground), 200초 (background)
```

```kotlin
// BAD: 메인 스레드에서 무거운 작업
class BadActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // 이 작업이 5초 이상 걸리면 ANR!
        val result = heavyComputation()
    }
}

// GOOD: 백그라운드 스레드로 분리
class GoodActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        lifecycleScope.launch {
            val result = withContext(Dispatchers.Default) {
                heavyComputation()
            }
            // UI 업데이트는 Main에서
            textView.text = result
        }
    }
}
```

### 실시간 스케줄링 (Real-Time)

Linux는 CFS 외에 실시간 스케줄링 정책도 제공한다:

| 정책 | 설명 |
|------|------|
| SCHED_FIFO | 실시간 FIFO. 같은 우선순위 내 선입선출 |
| SCHED_RR | 실시간 Round Robin |
| SCHED_NORMAL | 일반 CFS 스케줄링 |

Android의 오디오, 센서 처리 등 지연에 민감한 작업은 실시간 우선순위를 사용한다.

### 멀티코어 스케줄링과 big.LITTLE

최신 Android 기기는 big.LITTLE(또는 DynamIQ) 아키텍처를 사용한다:

```
big 코어 (고성능, 고전력)  ← UI 렌더링, 앱 실행
LITTLE 코어 (저성능, 저전력) ← 백그라운드, 센서 처리

EAS (Energy Aware Scheduling):
- 작업의 부하에 따라 적절한 코어에 배치
- 가벼운 작업은 LITTLE 코어로 → 배터리 절약
- 무거운 작업은 big 코어로 → 성능 확보
```

## 🔗 관련 개념

- [[00-CS-기초/운영체제/프로세스-관리|프로세스 관리]]
- [[00-CS-기초/동시성/프로세스-vs-스레드|프로세스 vs 스레드]]
- [[00-CS-기초/동시성/동기-vs-비동기|동기 vs 비동기]]
- [[00-CS-기초/동시성/블로킹-vs-논블로킹|블로킹 vs 논블로킹]]

## 📚 더 보기

- [Linux CFS Scheduler Documentation](https://docs.kernel.org/scheduler/sched-design-CFS.html)
- [Android Developer - Performance](https://developer.android.com/topic/performance)

---

**핵심 요약:** Android는 Linux CFS 기반으로 공정하게 CPU 배분. UI 스레드는 높은 우선순위, 백그라운드는 cgroup으로 제한. ANR 방지를 위해 무거운 작업은 반드시 백그라운드로.
