---
tags: [os, filesystem, android, storage, scoped-storage, ext4]
---

# 파일 시스템

## 💡 핵심 개념

**파일 시스템(File System)**은 저장 장치에서 데이터를 조직하고 접근하는 방법을 정의한다. 파일의 이름, 위치, 권한, 메타데이터를 관리하며, 계층적 디렉토리 구조를 제공한다. Android는 Linux의 ext4/f2fs 파일 시스템 위에서 앱별 격리된 저장소 모델을 구축했다.

## 📌 왜 필요한가?

Android 앱 개발에서 파일 읽기/쓰기, 사진 저장, 캐시 관리 등은 필수다. Scoped Storage 도입 이후 파일 접근 방식이 크게 바뀌었으므로 파일 시스템의 원리와 Android의 저장소 모델을 이해해야 한다.

## 🔍 자세히

### 파일 시스템의 기본 구조

```
파일 시스템 구조:
┌──────────────────┐
│  Boot Block      │ 부팅 정보
├──────────────────┤
│  Super Block     │ 파일 시스템 메타데이터 (크기, 블록 수 등)
├──────────────────┤
│  Inode Table     │ 각 파일의 메타데이터 (크기, 권한, 블록 위치)
├──────────────────┤
│  Data Blocks     │ 실제 파일 데이터
└──────────────────┘
```

**Inode (Index Node)**:
- 파일 하나당 하나의 inode
- 파일 크기, 소유자, 권한, 타임스탬프, 데이터 블록 위치 저장
- 파일 이름은 inode에 없음 → 디렉토리 엔트리에 저장

### Linux 파일 시스템 종류

| 파일 시스템 | 특징 | Android 사용 |
|-------------|------|--------------|
| ext4 | 저널링, 안정적 | 내부 저장소 (기존) |
| f2fs | 플래시 최적화, SSD/eMMC에 유리 | 내부 저장소 (최신) |
| FAT32/exFAT | 범용, 크로스 플랫폼 호환 | SD 카드 |
| FUSE | 유저 스페이스 파일 시스템 | Scoped Storage 구현 |

### Android 저장소 구조

```
/ (root)
├── /system        → Android OS 파일 (읽기 전용)
├── /data          → 앱 데이터
│   ├── /data/data/com.example.app/    → 내부 저장소
│   │   ├── files/                     → getFilesDir()
│   │   ├── cache/                     → getCacheDir()
│   │   ├── databases/                 → SQLite DB
│   │   └── shared_prefs/             → SharedPreferences
│   └── /data/media/0/                → 공용 저장소
│       ├── DCIM/
│       ├── Pictures/
│       ├── Download/
│       └── Documents/
├── /storage/emulated/0  → 외부 저장소 (에뮬레이트)
└── /proc, /sys          → 가상 파일 시스템
```

### 내부 저장소 (Internal Storage)

앱 전용 영역. 다른 앱이 접근할 수 없다.

```kotlin
// 내부 저장소에 파일 쓰기
fun writeToInternal(context: Context, filename: String, content: String) {
    context.openFileOutput(filename, Context.MODE_PRIVATE).use { fos ->
        fos.write(content.toByteArray())
    }
}

// 내부 저장소에서 파일 읽기
fun readFromInternal(context: Context, filename: String): String {
    return context.openFileInput(filename).bufferedReader().use {
        it.readText()
    }
}

// 캐시 디렉토리 사용
fun writeCacheFile(context: Context) {
    val cacheFile = File(context.cacheDir, "temp_data.json")
    cacheFile.writeText("{\"key\": \"value\"}")
    // 시스템이 저장 공간 부족 시 자동 삭제 가능
}

// 파일 경로 확인
val filesDir = context.filesDir       // /data/data/패키지명/files
val cacheDir = context.cacheDir       // /data/data/패키지명/cache
```

### 외부 저장소와 Scoped Storage

Android 10(API 29)부터 **Scoped Storage**가 도입되었다:

```
Android 9 이하: READ/WRITE_EXTERNAL_STORAGE로 전체 외부 저장소 접근
Android 10+:   Scoped Storage → 앱별 격리, MediaStore로 공유 파일 접근
Android 11+:   Scoped Storage 강제 적용
Android 13+:   READ_MEDIA_IMAGES, READ_MEDIA_VIDEO, READ_MEDIA_AUDIO 세분화
```

```kotlin
// 앱 전용 외부 저장소 (권한 불필요)
val appExternalDir = context.getExternalFilesDir(null)
// /storage/emulated/0/Android/data/패키지명/files

val picturesDir = context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)
// /storage/emulated/0/Android/data/패키지명/files/Pictures

// MediaStore로 공용 저장소에 이미지 저장 (Scoped Storage)
fun saveImageToGallery(context: Context, bitmap: Bitmap, displayName: String) {
    val contentValues = ContentValues().apply {
        put(MediaStore.Images.Media.DISPLAY_NAME, displayName)
        put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg")
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES)
            put(MediaStore.Images.Media.IS_PENDING, 1)
        }
    }

    val uri = context.contentResolver.insert(
        MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
        contentValues
    )

    uri?.let {
        context.contentResolver.openOutputStream(it)?.use { os ->
            bitmap.compress(Bitmap.CompressFormat.JPEG, 90, os)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            contentValues.clear()
            contentValues.put(MediaStore.Images.Media.IS_PENDING, 0)
            context.contentResolver.update(it, contentValues, null, null)
        }
    }
}
```

### SAF (Storage Access Framework)

사용자가 직접 파일/폴더를 선택하는 방식. 모든 Android 버전에서 동작한다:

```kotlin
// 파일 선택 (읽기)
val openDocumentLauncher = registerForActivityResult(
    ActivityResultContracts.OpenDocument()
) { uri: Uri? ->
    uri?.let { readFileFromUri(it) }
}

// 파일 선택기 열기
openDocumentLauncher.launch(arrayOf("application/pdf", "text/*"))

// URI에서 파일 읽기
fun readFileFromUri(uri: Uri) {
    contentResolver.openInputStream(uri)?.bufferedReader()?.use { reader ->
        val content = reader.readText()
    }
}

// 영구 권한 유지
contentResolver.takePersistableUriPermission(
    uri,
    Intent.FLAG_GRANT_READ_URI_PERMISSION
)
```

### 파일 권한 (Linux Permission)

```bash
# ADB로 파일 권한 확인
adb shell ls -la /data/data/com.example.app/files/

# 출력 예시:
# -rw-rw---- 1 u0_a123 u0_a123 1024 Feb 01 12:00 config.json
# drwxrwx--x 2 u0_a123 u0_a123 4096 Feb 01 12:00 cache/
```

```
권한 표기: -rwxrwxrwx
           │├──┤├──┤├──┤
           │  │   │   └── Others (기타)
           │  │   └────── Group (그룹)
           │  └────────── Owner (소유자)
           └───────────── 파일 유형 (- 파일, d 디렉토리)

r = 읽기 (4)
w = 쓰기 (2)
x = 실행 (1)
```

Android에서 각 앱은 고유한 Linux UID를 가진다. 앱의 내부 저장소는 해당 UID만 접근 가능하다.

### 저널링 (Journaling)

파일 시스템 변경 사항을 로그(저널)에 먼저 기록한 뒤 실제 반영한다. 전원 차단 시 데이터 손상을 방지한다.

```
쓰기 과정:
1. 저널에 변경 내용 기록
2. 실제 데이터 블록에 쓰기
3. 저널에서 완료 표시

비정상 종료 시:
→ 저널을 보고 미완료 작업을 롤백 또는 재실행
```

ext4와 f2fs 모두 저널링을 지원한다.

## 🔗 관련 개념

- [[00-CS-기초/운영체제/Linux-기초|Linux 기초]]
- [[00-CS-기초/운영체제/커널-모드-vs-유저-모드|커널 모드 vs 유저 모드]]
- [[00-CS-기초/보안-기초/인증-vs-인가|인증 vs 인가]]

## 📚 더 보기

- [Android Developer - Data and File Storage](https://developer.android.com/training/data-storage)
- [Android Developer - Scoped Storage](https://developer.android.com/about/versions/11/privacy/storage)

---

**핵심 요약:** Android는 Linux ext4/f2fs 기반. 내부 저장소는 앱 전용, 외부는 Scoped Storage로 격리. MediaStore/SAF로 공유 파일 접근.
