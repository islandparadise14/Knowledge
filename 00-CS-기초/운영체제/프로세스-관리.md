---
tags: [os, process, android, zygote, lmk, lifecycle]
---

# 프로세스 관리

## 💡 핵심 개념

**프로세스(Process)**는 실행 중인 프로그램의 인스턴스다. 운영체제는 프로세스의 생성, 실행, 종료를 관리하며, 각 프로세스에 메모리와 CPU 시간을 할당한다. Android는 Linux 커널 위에서 동작하므로 Linux의 프로세스 모델을 기반으로 하되, Zygote와 LMK 같은 Android 고유의 메커니즘을 추가했다.

## 📌 왜 필요한가?

Android 앱은 각각 독립된 Linux 프로세스에서 실행된다. 앱의 생명주기, 메모리 관리, ANR 문제를 이해하려면 프로세스 관리 원리를 알아야 한다.

## 🔍 자세히

### 프로세스의 구성 요소

프로세스는 다음 요소로 구성된다:

| 구성 요소 | 설명 |
|-----------|------|
| PID | 프로세스 고유 식별자 |
| 메모리 공간 | 코드, 데이터, 힙, 스택 영역 |
| PCB (Process Control Block) | 프로세스 상태 정보를 담는 자료구조 |
| 파일 디스크립터 | 열린 파일, 소켓 등의 참조 |

### 프로세스 상태 전이

```
         생성(new)
           │
           ▼
        준비(ready) ◄──── 대기(waiting)
           │                   ▲
           ▼                   │
        실행(running) ─────────┘
           │
           ▼
        종료(terminated)
```

- **생성(New)**: 프로세스 생성 중
- **준비(Ready)**: CPU 할당을 기다리는 상태
- **실행(Running)**: CPU에서 명령어 실행 중
- **대기(Waiting)**: I/O 완료 등 이벤트 대기
- **종료(Terminated)**: 실행 완료

### Android의 Zygote 프로세스

Android에서 모든 앱 프로세스는 **Zygote**에서 `fork()`된다. Zygote는 Android 런타임과 공통 라이브러리를 미리 로드해둔 프로세스다.

```
System Boot
    │
    ▼
init 프로세스 (PID 1)
    │
    ├── Zygote 프로세스
    │      │
    │      ├── fork() → System Server
    │      ├── fork() → App 프로세스 A
    │      ├── fork() → App 프로세스 B
    │      └── fork() → App 프로세스 C
    │
    └── Native Daemons (servicemanager 등)
```

**Zygote의 장점:**
- **빠른 앱 실행**: 공통 클래스와 리소스가 이미 로드되어 있어 fork만 하면 됨
- **메모리 절약**: fork 시 COW(Copy-On-Write)로 메모리 공유
- **일관된 초기 상태**: 모든 앱이 동일한 기본 환경에서 시작

### Android 앱 프로세스 우선순위

Android는 프로세스를 중요도에 따라 5단계로 분류한다:

| 우선순위 | 유형 | 예시 |
|----------|------|------|
| 1 (최고) | Foreground | 현재 화면에 보이는 Activity |
| 2 | Visible | 다이얼로그 뒤의 Activity |
| 3 | Service | 백그라운드 음악 재생 |
| 4 | Cached | 최근 사용한 앱 (백그라운드) |
| 5 (최저) | Empty | 아무 컴포넌트도 없는 프로세스 |

### LMK (Low Memory Killer)

Android는 Linux의 OOM Killer를 확장한 **Low Memory Killer**를 사용한다. 메모리가 부족해지면 우선순위가 낮은 프로세스부터 종료한다.

```
메모리 충분 ◄────────────────────────► 메모리 부족
[Foreground] [Visible] [Service] [Cached] [Empty]
                                    ← 이쪽부터 kill
```

ADB로 프로세스 우선순위를 확인할 수 있다:

```bash
# 실행 중인 프로세스 목록
adb shell ps -A | grep "com.example"

# 프로세스의 oom_adj_score 확인 (낮을수록 중요)
adb shell cat /proc/<PID>/oom_score_adj

# 메모리 사용량 확인
adb shell dumpsys meminfo com.example.app
```

### 프로세스 생명주기와 Android 컴포넌트

```kotlin
// Application 클래스 - 프로세스 시작 시 최초 1회 호출
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        // 프로세스 레벨 초기화
        // DI 컨테이너, 로깅, 크래시 리포팅 설정
    }

    override fun onTrimMemory(level: Int) {
        super.onTrimMemory(level)
        when (level) {
            TRIM_MEMORY_RUNNING_LOW -> {
                // 캐시 정리
            }
            TRIM_MEMORY_UI_HIDDEN -> {
                // UI 관련 리소스 해제
            }
            TRIM_MEMORY_COMPLETE -> {
                // 가능한 모든 메모리 해제
            }
        }
    }
}
```

### 멀티 프로세스 앱

Android에서는 `android:process` 속성으로 컴포넌트를 별도 프로세스에서 실행할 수 있다:

```xml
<!-- AndroidManifest.xml -->
<service
    android:name=".MusicService"
    android:process=":music" />
<!-- ':music' → com.example.app:music 프로세스에서 실행 -->
```

```kotlin
// 주의: 별도 프로세스는 별도 Application 인스턴스를 가진다
// 프로세스 간 데이터 공유는 IPC(Binder)를 통해야 한다

// 현재 프로세스 이름 확인
fun getCurrentProcessName(): String {
    return if (Build.VERSION.SDK_INT >= 28) {
        Application.getProcessName()
    } else {
        val pid = android.os.Process.myPid()
        val manager = getSystemService(ACTIVITY_SERVICE) as ActivityManager
        manager.runningAppProcesses
            ?.find { it.pid == pid }
            ?.processName ?: ""
    }
}
```

### Context Switch (문맥 교환)

CPU가 한 프로세스에서 다른 프로세스로 전환할 때 현재 상태를 저장하고 새 프로세스의 상태를 복원하는 과정이다.

```
프로세스 A 실행 → PCB에 상태 저장 → 프로세스 B의 PCB 복원 → 프로세스 B 실행
```

**비용**: 레지스터 저장/복원, 캐시 무효화 등으로 오버헤드가 발생한다. Android에서 멀티 프로세스 앱은 이 비용을 고려해야 한다.

### fork()와 COW (Copy-On-Write)

Linux의 `fork()`는 부모 프로세스를 복제하지만 실제 메모리를 즉시 복사하지 않는다. 쓰기가 발생할 때만 해당 페이지를 복사하는 **COW** 방식을 사용한다.

```
fork() 직후:
  부모 프로세스 ─┐
                 ├── 공유 메모리 페이지 (읽기 전용)
  자식 프로세스 ─┘

쓰기 발생 시:
  부모 프로세스 → 원본 페이지
  자식 프로세스 → 복사된 페이지 (수정됨)
```

Android의 Zygote가 효율적인 이유가 바로 이 COW 덕분이다.

## 🔗 관련 개념

- [[00-CS-기초/동시성/프로세스-vs-스레드|프로세스 vs 스레드]]
- [[00-CS-기초/메모리/스택-vs-힙|스택 vs 힙]]
- [[00-CS-기초/운영체제/스케줄링|스케줄링]]
- [[00-CS-기초/운영체제/IPC-프로세스간-통신|IPC 프로세스간 통신]]
- [[00-CS-기초/운영체제/커널-모드-vs-유저-모드|커널 모드 vs 유저 모드]]

## 📚 더 보기

- [Android Developer - Processes and App Lifecycle](https://developer.android.com/guide/components/activities/process-lifecycle)
- [Android Developer - Memory Management](https://developer.android.com/topic/performance/memory-overview)

---

**핵심 요약:** Android 앱은 Zygote에서 fork된 독립 Linux 프로세스. LMK가 우선순위 기반으로 메모리 관리. onTrimMemory로 메모리 압박에 대응.
