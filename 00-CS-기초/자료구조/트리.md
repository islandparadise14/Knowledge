---
tags: [CS, ìë£Œêµ¬ì¡°, íŠ¸ë¦¬, ì´ì§„íŠ¸ë¦¬, BST, TreeMap, Red-Black-Tree]
---

# íŠ¸ë¦¬

## ğŸ’¡ í•µì‹¬ ê°œë…

íŠ¸ë¦¬(Tree)ëŠ” ë…¸ë“œë“¤ì´ ë¶€ëª¨-ìì‹ ê´€ê³„ë¡œ ì—°ê²°ëœ **ë¹„ìˆœí™˜ ê³„ì¸µ êµ¬ì¡°** ìë£Œêµ¬ì¡°ì´ë‹¤. ìµœìƒìœ„ ë…¸ë“œë¥¼ ë£¨íŠ¸(Root)ë¼ í•˜ë©°, ê° ë…¸ë“œëŠ” 0ê°œ ì´ìƒì˜ ìì‹ ë…¸ë“œë¥¼ ê°€ì§„ë‹¤. ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬(BST)ëŠ” ì™¼ìª½ ìì‹ < ë¶€ëª¨ < ì˜¤ë¥¸ìª½ ìì‹ ê·œì¹™ì„ ë§Œì¡±í•˜ì—¬ íš¨ìœ¨ì ì¸ íƒìƒ‰ì„ ê°€ëŠ¥í•˜ê²Œ í•œë‹¤.

## ğŸ“Œ ì™œ í•„ìš”í•œê°€?

Androidì˜ View ê³„ì¸µ êµ¬ì¡°ê°€ íŠ¸ë¦¬ í˜•íƒœì´ë©°, `TreeMap`ì€ ì •ë ¬ëœ Mapì´ í•„ìš”í•  ë•Œ ì‚¬ìš©í•œë‹¤. JSON/XML íŒŒì‹± ê²°ê³¼ë„ íŠ¸ë¦¬ êµ¬ì¡°ì´ê³ , Room DBì˜ ì¸ë±ìŠ¤ë„ B-Tree ê¸°ë°˜ì´ë‹¤.

## ğŸ” ìì„¸íˆ

### íŠ¸ë¦¬ ê¸°ë³¸ ìš©ì–´

```
        A          â† ë£¨íŠ¸(Root), ê¹Šì´ 0
       / \
      B   C        â† ê¹Šì´ 1
     / \   \
    D   E   F      â† ê¹Šì´ 2 (ë¦¬í”„ ë…¸ë“œ)
```

- **ë£¨íŠ¸(Root)**: ìµœìƒìœ„ ë…¸ë“œ (A)
- **ë¦¬í”„(Leaf)**: ìì‹ì´ ì—†ëŠ” ë…¸ë“œ (D, E, F)
- **ê¹Šì´(Depth)**: ë£¨íŠ¸ì—ì„œ í•´ë‹¹ ë…¸ë“œê¹Œì§€ì˜ ê°„ì„  ìˆ˜
- **ë†’ì´(Height)**: í•´ë‹¹ ë…¸ë“œì—ì„œ ê°€ì¥ ë¨¼ ë¦¬í”„ê¹Œì§€ì˜ ê°„ì„  ìˆ˜
- **ì°¨ìˆ˜(Degree)**: ìì‹ ë…¸ë“œì˜ ìˆ˜

### ì´ì§„ íŠ¸ë¦¬ êµ¬í˜„

```kotlin
data class TreeNode<T>(
    val value: T,
    var left: TreeNode<T>? = null,
    var right: TreeNode<T>? = null
)

// íŠ¸ë¦¬ ìˆœíšŒ
fun <T> inOrder(node: TreeNode<T>?, result: MutableList<T> = mutableListOf()): List<T> {
    node ?: return result
    inOrder(node.left, result)    // ì™¼ìª½
    result.add(node.value)        // í˜„ì¬
    inOrder(node.right, result)   // ì˜¤ë¥¸ìª½
    return result
}

fun <T> preOrder(node: TreeNode<T>?, result: MutableList<T> = mutableListOf()): List<T> {
    node ?: return result
    result.add(node.value)        // í˜„ì¬
    preOrder(node.left, result)   // ì™¼ìª½
    preOrder(node.right, result)  // ì˜¤ë¥¸ìª½
    return result
}

fun <T> postOrder(node: TreeNode<T>?, result: MutableList<T> = mutableListOf()): List<T> {
    node ?: return result
    postOrder(node.left, result)  // ì™¼ìª½
    postOrder(node.right, result) // ì˜¤ë¥¸ìª½
    result.add(node.value)        // í˜„ì¬
    return result
}
```

### ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ (BST)

```kotlin
class BST<T : Comparable<T>> {
    private var root: TreeNode<T>? = null

    fun insert(value: T) {
        root = insertRec(root, value)
    }

    private fun insertRec(node: TreeNode<T>?, value: T): TreeNode<T> {
        if (node == null) return TreeNode(value)
        when {
            value < node.value -> node.left = insertRec(node.left, value)
            value > node.value -> node.right = insertRec(node.right, value)
        }
        return node
    }

    fun search(value: T): Boolean {
        var current = root
        while (current != null) {
            current = when {
                value < current.value -> current.left
                value > current.value -> current.right
                else -> return true
            }
        }
        return false
    }
}
```

### ì‹œê°„ ë³µì¡ë„ ë¹„êµ

| ì—°ì‚° | BST (í‰ê· ) | BST (ìµœì•…) | ê· í˜• íŠ¸ë¦¬ (TreeMap) |
|------|-----------|-----------|-------------------|
| ê²€ìƒ‰ | O(log n) | O(n) | **O(log n)** |
| ì‚½ì… | O(log n) | O(n) | **O(log n)** |
| ì‚­ì œ | O(log n) | O(n) | **O(log n)** |
| ìˆœíšŒ | O(n) | O(n) | O(n) |

> BSTì˜ ìµœì•…ì€ í¸í–¥ íŠ¸ë¦¬(í•œìª½ìœ¼ë¡œë§Œ ì¹˜ìš°ì¹œ)ì¼ ë•Œ ë°œìƒ. Red-Black Treeë¡œ í•´ê²°.

### TreeMap - ì •ë ¬ëœ Map

Kotlin/Javaì˜ `TreeMap`ì€ **Red-Black Tree**(ìê°€ ê· í˜• ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬) ê¸°ë°˜ì´ë‹¤.

```kotlin
import java.util.TreeMap

// í‚¤ê°€ ìë™ ì •ë ¬ë˜ëŠ” Map
val treeMap = TreeMap<String, Int>()
treeMap["banana"] = 2
treeMap["apple"] = 1
treeMap["cherry"] = 3

println(treeMap.keys) // [apple, banana, cherry] - ì •ë ¬ë¨

// ë²”ìœ„ ì¿¼ë¦¬ ì§€ì›
treeMap.subMap("apple", "cherry")   // {apple=1, banana=2}
treeMap.headMap("cherry")           // {apple=1, banana=2}
treeMap.tailMap("banana")           // {banana=2, cherry=3}
treeMap.firstKey()                  // "apple"
treeMap.lastKey()                   // "cherry"
```

### Android ì‹¤ì „ í™œìš©

```kotlin
// 1. View ê³„ì¸µ êµ¬ì¡° íƒìƒ‰ - View íŠ¸ë¦¬
fun findAllTextViews(root: View): List<TextView> {
    val result = mutableListOf<TextView>()
    if (root is TextView) result.add(root)
    if (root is ViewGroup) {
        for (i in 0 until root.childCount) {
            result.addAll(findAllTextViews(root.getChildAt(i)))
        }
    }
    return result
}

// 2. JSON íŒŒì‹± ê²°ê³¼ â†’ íŠ¸ë¦¬ êµ¬ì¡°
// Gson/Moshiê°€ JSONì„ ê°ì²´ íŠ¸ë¦¬ë¡œ ë³€í™˜
data class Category(
    val name: String,
    val children: List<Category> = emptyList()
)

// 3. TreeMapìœ¼ë¡œ ì •ë ¬ëœ ìºì‹œ êµ¬í˜„
class SortedCache<K : Comparable<K>, V> {
    private val cache = TreeMap<K, V>()

    fun put(key: K, value: V) { cache[key] = value }
    fun getRange(from: K, to: K): Map<K, V> = cache.subMap(from, to)
}

// 4. Composeì˜ Composition Tree
// Jetpack ComposeëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ìŠ¬ë¡¯ í…Œì´ë¸”(íŠ¸ë¦¬ êµ¬ì¡°)ë¡œ UIë¥¼ ê´€ë¦¬
```

### ì£¼ìš” íŠ¸ë¦¬ ì¢…ë¥˜ ì •ë¦¬

| íŠ¸ë¦¬ ì¢…ë¥˜ | íŠ¹ì§• | í™œìš© |
|----------|------|------|
| ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ | ì™¼ < ë¶€ëª¨ < ì˜¤ | ì •ë ¬ëœ ë°ì´í„° íƒìƒ‰ |
| Red-Black Tree | ìê°€ ê· í˜• BST | Java TreeMap, TreeSet |
| B-Tree / B+Tree | ë‹¤ì§„ íƒìƒ‰ íŠ¸ë¦¬ | DB ì¸ë±ìŠ¤, Room DB |
| Trie | ë¬¸ìì—´ ì ‘ë‘ì‚¬ íŠ¸ë¦¬ | ìë™ì™„ì„±, ê²€ìƒ‰ì–´ ì¶”ì²œ |

## ğŸ”— ê´€ë ¨ ê°œë…

- [[00-CS-ê¸°ì´ˆ/ìë£Œêµ¬ì¡°/í•´ì‹œë§µ|í•´ì‹œë§µ]]
- [[00-CS-ê¸°ì´ˆ/ìë£Œêµ¬ì¡°/í™ê³¼-ìš°ì„ ìˆœìœ„-í|í™ê³¼ ìš°ì„ ìˆœìœ„ í]]
- [[00-CS-ê¸°ì´ˆ/ìë£Œêµ¬ì¡°/ê·¸ë˜í”„|ê·¸ë˜í”„]]
- [[00-CS-ê¸°ì´ˆ/ì•Œê³ ë¦¬ì¦˜/íƒìƒ‰-ì•Œê³ ë¦¬ì¦˜|íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜]]
- [[00-CS-ê¸°ì´ˆ/ë°ì´í„°ë² ì´ìŠ¤/ì¸ë±ìŠ¤|ì¸ë±ìŠ¤ (B-Tree)]]

## ğŸ“š ë” ë³´ê¸°

- [Kotlin TreeMap](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/java.util.-tree-map/)
- [Red-Black Tree ì‹œê°í™”](https://www.cs.usfca.edu/~galles/visualization/RedBlack.html)

---

**í•µì‹¬ ìš”ì•½:** íŠ¸ë¦¬ëŠ” ê³„ì¸µì  ë°ì´í„°ë¥¼ í‘œí˜„í•˜ëŠ” ìë£Œêµ¬ì¡°ë¡œ, Androidì˜ View ê³„ì¸µê³¼ DB ì¸ë±ìŠ¤ê°€ ëŒ€í‘œì ì´ë©°, ì •ë ¬ëœ Mapì´ í•„ìš”í•˜ë©´ TreeMap(Red-Black Tree)ì„ ì‚¬ìš©í•œë‹¤.
