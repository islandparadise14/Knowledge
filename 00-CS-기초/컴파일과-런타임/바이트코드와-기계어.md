---
tags: [cs, compile, bytecode, machine-code, jvm, dex]
---

# 바이트코드와 기계어

## 💡 핵심 개념

**기계어**(Machine Code)는 CPU가 직접 실행하는 이진 명령어이고, **바이트코드**(Bytecode)는 가상 머신(VM)이 해석하는 중간 코드이다. Kotlin은 `.class`(JVM 바이트코드)를 거쳐 `.dex`(Dalvik 바이트코드)로 변환되며, ART가 이를 기계어로 최종 변환한다.

## 📌 왜 필요한가?

"Write Once, Run Anywhere"의 원리, ProGuard/R8의 동작, 디컴파일/리버스 엔지니어링 이해, 성능 최적화(인라이닝, 바이트코드 레벨 최적화)의 기반 지식이다.

## 🔍 자세히

### 소스 코드 → 기계어 변환 과정

```
Kotlin 소스 (.kt)
     │ kotlinc
     ▼
JVM 바이트코드 (.class)     ← 스택 기반, 클래스 단위
     │ D8 / R8
     ▼
Dalvik 바이트코드 (.dex)    ← 레지스터 기반, 앱 단위
     │ ART (AOT / JIT)
     ▼
네이티브 기계어              ← CPU가 직접 실행 (ARM, x86)
```

### 바이트코드 vs 기계어

| | 바이트코드 | 기계어 |
|---|---|---|
| 실행 주체 | 가상 머신 (JVM, ART) | CPU 직접 실행 |
| 플랫폼 의존 | 독립적 (이식성) | CPU 아키텍처 종속 |
| 읽기 난이도 | 사람이 읽을 수 있음 | 이진수 |
| 성능 | VM 해석 오버헤드 | 최고 성능 |
| 예시 | `.class`, `.dex` | ARM64 명령어 |

### JVM 바이트코드 (스택 기반)

```kotlin
// Kotlin 소스
fun add(a: Int, b: Int): Int = a + b
```

```
// JVM 바이트코드 (.class) - javap -c 로 확인
0: iload_0    // 스택에 a push
1: iload_1    // 스택에 b push
2: iadd       // 스택에서 두 값 pop → 더한 결과 push
3: ireturn    // 스택 top 반환
```

### Dalvik 바이트코드 (레지스터 기반)

```
// DEX 바이트코드 - 같은 add 함수
add-int v0, p0, p1   // v0 = p0 + p1 (레지스터 직접 연산)
return v0             // v0 반환

// 명령어 수가 적고, 메모리 접근이 적어 모바일에 효율적
```

### 바이트코드 확인 방법

```bash
# JVM 바이트코드 확인
javap -c MyClass.class

# DEX 바이트코드 확인
# Android Studio → Build → Analyze APK → classes.dex → 클래스 선택

# Kotlin → 바이트코드 확인 (Android Studio)
# Tools → Kotlin → Show Kotlin Bytecode → Decompile
```

### Kotlin 컴파일러가 생성하는 바이트코드

```kotlin
// data class
data class User(val name: String, val age: Int)
// → equals(), hashCode(), toString(), copy(), componentN() 바이트코드 자동 생성

// object (싱글톤)
object AppConfig { val url = "https://api.com" }
// → static INSTANCE 필드 + static {} 초기화 블록 생성

// 확장 함수
fun String.addExclamation() = "$this!"
// → static 메서드로 변환: addExclamation(String receiver)

// inline 함수
inline fun measure(block: () -> Unit) { /* ... */ }
// → 호출 지점에 바이트코드가 직접 삽입 (함수 호출 오버헤드 제거)
```

### 네이티브 기계어 (NDK)

```kotlin
// JNI로 네이티브(C/C++) 코드 호출 → 기계어로 직접 컴파일
external fun nativeAdd(a: Int, b: Int): Int

// C 코드 → ARM64 기계어로 컴파일
// GCC/Clang이 .so 파일 생성
// ABI: armeabi-v7a, arm64-v8a, x86, x86_64
```

```groovy
// build.gradle.kts - NDK ABI 필터
android {
    defaultConfig {
        ndk {
            abiFilters += listOf("arm64-v8a", "armeabi-v7a")
        }
    }
}
```

### R8이 바이트코드에 하는 일

```
원본 바이트코드
     │
     ├─ Tree Shaking: 사용하지 않는 클래스/메서드 제거
     ├─ 난독화: UserRepository → a, fetchData → b
     ├─ 최적화: 인라이닝, 상수 폴딩, 데드 코드 제거
     │
     ▼
최적화된 DEX 바이트코드 (크기 ↓, 성능 ↑)
```

## 🔗 관련 개념

- [[00-CS-기초/컴파일과-런타임/컴파일-과정|컴파일 과정]]
- [[00-CS-기초/JVM/DEX-파일|DEX 파일]]
- [[00-CS-기초/JVM/JIT-컴파일|JIT 컴파일]]
- [[00-CS-기초/JVM/Dalvik-vs-ART|Dalvik vs ART]]
- [[00-CS-기초/컴파일과-런타임/인터프리터-vs-컴파일러|인터프리터 vs 컴파일러]]

## 📚 더 보기

- [Kotlin Bytecode - Show Kotlin Bytecode](https://kotlinlang.org/docs/faq.html)
- [Android NDK 가이드](https://developer.android.com/ndk/guides)
- [R8 최적화](https://developer.android.com/build/shrink-code)

---

**핵심 요약:** 바이트코드는 VM이 해석하는 중간 코드, 기계어는 CPU가 직접 실행. Kotlin은 JVM 바이트코드(스택 기반) → DEX 바이트코드(레지스터 기반) → 네이티브 기계어(ART가 변환)로 최종 실행된다.
