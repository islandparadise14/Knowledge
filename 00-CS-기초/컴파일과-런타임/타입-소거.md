---
tags: [CS, íƒ€ì…ì†Œê±°, ì œë„¤ë¦­, JVM, Kotlin, reified]
---

# íƒ€ì… ì†Œê±° (Type Erasure)

## ğŸ’¡ í•µì‹¬ ê°œë…

íƒ€ì… ì†Œê±°(Type Erasure)ë€ ì œë„¤ë¦­ íƒ€ì… ì •ë³´ê°€ ì»´íŒŒì¼ íƒ€ì„ì—ë§Œ ì¡´ì¬í•˜ê³ , ëŸ°íƒ€ì„ì—ëŠ” ì œê±°ë˜ëŠ” JVMì˜ íŠ¹ì„±ì´ë‹¤. ì¦‰, `List<String>`ê³¼ `List<Int>`ëŠ” ëŸ°íƒ€ì„ì— ë™ì¼í•œ `List`ë¡œ ì·¨ê¸‰ëœë‹¤. ì´ëŠ” Java 5ì—ì„œ ì œë„¤ë¦­ì„ ë„ì…í•  ë•Œ í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ ì§€í•˜ê¸° ìœ„í•œ ì„¤ê³„ ê²°ì •ì´ë‹¤.

## ğŸ“Œ ì™œ í•„ìš”í•œê°€?

ì•ˆë“œë¡œì´ë“œ ê°œë°œì—ì„œ Gson/Moshië¡œ JSON íŒŒì‹±í•  ë•Œ `TypeToken`ì´ í•„ìš”í•œ ì´ìœ , Kotlinì˜ `reified` í‚¤ì›Œë“œê°€ ì¡´ì¬í•˜ëŠ” ì´ìœ , Room DAOì—ì„œ ì œë„¤ë¦­ ë°˜í™˜ íƒ€ì…ì´ ì œí•œë˜ëŠ” ì´ìœ ê°€ ëª¨ë‘ íƒ€ì… ì†Œê±° ë•Œë¬¸ì´ë‹¤.

## ğŸ” ìì„¸íˆ

### íƒ€ì… ì†Œê±°ì˜ ë™ì‘

```kotlin
// ì»´íŒŒì¼ ì „ (ì†ŒìŠ¤ ì½”ë“œ)
val strings: List<String> = listOf("a", "b")
val ints: List<Int> = listOf(1, 2)

// ì»´íŒŒì¼ í›„ (ë°”ì´íŠ¸ì½”ë“œ) - íƒ€ì… íŒŒë¼ë¯¸í„° ì œê±°ë¨
val strings: List<*> = listOf("a", "b")  // String ì •ë³´ ì‚¬ë¼ì§
val ints: List<*> = listOf(1, 2)          // Int ì •ë³´ ì‚¬ë¼ì§

// ëŸ°íƒ€ì„ì— ì œë„¤ë¦­ íƒ€ì… ë¹„êµ ë¶ˆê°€
strings is List<String>  // ì»´íŒŒì¼ ì—ëŸ¬: Cannot check for erased type
strings is List<*>       // OK - ì™€ì¼ë“œì¹´ë“œëŠ” ê°€ëŠ¥
```

### íƒ€ì… ì†Œê±°ë¡œ ì¸í•œ ë¬¸ì œë“¤

```kotlin
// 1. ëŸ°íƒ€ì„ íƒ€ì… ì²´í¬ ë¶ˆê°€
fun checkType(list: List<*>) {
    if (list is List<String>) { } // ì»´íŒŒì¼ ì—ëŸ¬!
    if (list is List<*>) { }      // OK, í•˜ì§€ë§Œ ë¬´ì˜ë¯¸
}

// 2. ì˜¤ë²„ë¡œë”© ë¶ˆê°€ - ì‹œê·¸ë‹ˆì²˜ê°€ ë™ì¼í•´ì§
// fun process(list: List<String>) { }  // ì»´íŒŒì¼ ì—ëŸ¬:
// fun process(list: List<Int>) { }     // Platform declaration clash

// 3. ì œë„¤ë¦­ ë°°ì—´ ìƒì„± ë¶ˆê°€
// val array = Array<List<String>>(10) { listOf() } // ê²½ê³ 

// 4. ì œë„¤ë¦­ íƒ€ì…ì˜ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ë¶ˆê°€
// fun <T> create(): T = T() // ë¶ˆê°€ëŠ¥
```

### Kotlinì˜ reifiedë¡œ íƒ€ì… ì†Œê±° ìš°íšŒ

`inline` í•¨ìˆ˜ì™€ `reified` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ë©´ ëŸ°íƒ€ì„ì—ë„ ì œë„¤ë¦­ íƒ€ì… ì •ë³´ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ì¸ë¼ì¸ í•¨ìˆ˜ëŠ” í˜¸ì¶œ ì§€ì ì— ì½”ë“œê°€ ë³µì‚¬ë˜ë¯€ë¡œ, ì»´íŒŒì¼ëŸ¬ê°€ êµ¬ì²´ì ì¸ íƒ€ì…ì„ ì§ì ‘ ì‚½ì…í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.

```kotlin
// reified ì—†ì´ - íƒ€ì… ì •ë³´ë¥¼ Classë¡œ ì „ë‹¬í•´ì•¼ í•¨
fun <T> parseJson(json: String, clazz: Class<T>): T {
    return Gson().fromJson(json, clazz)
}
val user = parseJson("""{"name":"í™ê¸¸ë™"}""", User::class.java)

// reified ì‚¬ìš© - íƒ€ì… ì •ë³´ê°€ ëŸ°íƒ€ì„ì— ìœ ì§€ë¨
inline fun <reified T> parseJson(json: String): T {
    return Gson().fromJson(json, T::class.java)
}
val user = parseJson<User>("""{"name":"í™ê¸¸ë™"}""")

// reifiedë¡œ íƒ€ì… ì²´í¬ ê°€ëŠ¥
inline fun <reified T> List<*>.filterByType(): List<T> {
    return this.filterIsInstance<T>()
}

val mixed: List<Any> = listOf("hello", 1, "world", 2)
val strings: List<String> = mixed.filterByType<String>() // ["hello", "world"]
```

### Androidì—ì„œì˜ ì‹¤ì œ ì‚¬ë¡€

```kotlin
// 1. Intentì—ì„œ Parcelable ê°€ì ¸ì˜¤ê¸°
inline fun <reified T : Parcelable> Intent.getParcelableCompat(key: String): T? {
    return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
        getParcelableExtra(key, T::class.java)
    } else {
        @Suppress("DEPRECATION")
        getParcelableExtra(key) as? T
    }
}

// ì‚¬ìš©
val user = intent.getParcelableCompat<User>("user_data")

// 2. Fragmentì—ì„œ ViewModel ê°€ì ¸ì˜¤ê¸°
inline fun <reified VM : ViewModel> Fragment.viewModel(): Lazy<VM> {
    return lazy { ViewModelProvider(this)[VM::class.java] }
}

// ì‚¬ìš©
class UserFragment : Fragment() {
    private val viewModel by viewModel<UserViewModel>()
}

// 3. Moshi JSON íŒŒì‹± - TypeToken íŒ¨í„´
// íƒ€ì… ì†Œê±° ë•Œë¬¸ì— TypeTokenì´ í•„ìš”
val type = Types.newParameterizedType(
    List::class.java,
    User::class.java
)
val adapter: JsonAdapter<List<User>> = moshi.adapter(type)

// reifiedë¡œ ê¹”ë”í•˜ê²Œ
inline fun <reified T> Moshi.adapter(): JsonAdapter<T> {
    return adapter(T::class.java)
}
```

### íƒ€ì… ì†Œê±°ê°€ ì ìš©ë˜ì§€ ì•ŠëŠ” ê²½ìš°

```kotlin
// 1. í´ë˜ìŠ¤ ì„ ì–¸ì˜ ìŠˆí¼íƒ€ì… - ë¦¬í”Œë ‰ì…˜ìœ¼ë¡œ ì ‘ê·¼ ê°€ëŠ¥
abstract class TypeReference<T> {
    val type: Type = (javaClass.genericSuperclass as ParameterizedType)
        .actualTypeArguments[0]
}

// Gsonì˜ TypeToken ì›ë¦¬
val token = object : TypeToken<List<User>>() {}
// â†’ ìµëª… í´ë˜ìŠ¤ì˜ ìŠˆí¼íƒ€ì…ì— List<User> ì •ë³´ê°€ ë³´ì¡´ë¨

// 2. ì–´ë…¸í…Œì´ì…˜ì˜ íƒ€ì… íŒŒë¼ë¯¸í„° - ë³´ì¡´ë¨
// 3. í•„ë“œ/ë©”ì„œë“œì˜ ì„ ì–¸ëœ ì œë„¤ë¦­ íƒ€ì… - ë¦¬í”Œë ‰ì…˜ìœ¼ë¡œ ì ‘ê·¼ ê°€ëŠ¥
class Repository {
    val users: List<User> = listOf() // User ì •ë³´ê°€ í´ë˜ìŠ¤ ë©”íƒ€ë°ì´í„°ì— ë³´ì¡´
}
```

### star projectionê³¼ íƒ€ì… ì†Œê±°

```kotlin
// star projection (*)ì€ íƒ€ì… ì†Œê±°ëœ ìƒíƒœì—ì„œ ì•ˆì „í•˜ê²Œ ì‚¬ìš©í•˜ëŠ” ë°©ë²•
fun printSize(list: List<*>) {
    println(list.size) // OK
    // list.add("hello") // ì»´íŒŒì¼ ì—ëŸ¬ - íƒ€ì…ì„ ëª¨ë¥´ë¯€ë¡œ ì¶”ê°€ ë¶ˆê°€
}

// out projection
fun readOnly(list: List<out Any?>) {
    val item: Any? = list[0] // OK - ì½ê¸°ë§Œ ê°€ëŠ¥
}
```

## ğŸ”— ê´€ë ¨ ê°œë…

- [[00-CS-ê¸°ì´ˆ/ì»´íŒŒì¼ê³¼-ëŸ°íƒ€ì„/íƒ€ì…-ì‹œìŠ¤í…œ|íƒ€ì… ì‹œìŠ¤í…œ]]
- [[00-CS-ê¸°ì´ˆ/ì»´íŒŒì¼ê³¼-ëŸ°íƒ€ì„/ì»´íŒŒì¼-íƒ€ì„-vs-ëŸ°íƒ€ì„|ì»´íŒŒì¼ íƒ€ì„ vs ëŸ°íƒ€ì„]]
- [[00-CS-ê¸°ì´ˆ/ì»´íŒŒì¼ê³¼-ëŸ°íƒ€ì„/ë°”ì´íŠ¸ì½”ë“œì™€-ê¸°ê³„ì–´|ë°”ì´íŠ¸ì½”ë“œì™€ ê¸°ê³„ì–´]]
- [[00-CS-ê¸°ì´ˆ/JVM/JVM-êµ¬ì¡°|JVM êµ¬ì¡°]]

## ğŸ“š ë” ë³´ê¸°

- [Kotlin Reified Type Parameters](https://kotlinlang.org/docs/inline-functions.html#reified-type-parameters)
- [Java Type Erasure (Oracle)](https://docs.oracle.com/javase/tutorial/java/generics/erasure.html)

---

**í•µì‹¬ ìš”ì•½:** JVMì˜ íƒ€ì… ì†Œê±°ë¡œ ì¸í•´ ì œë„¤ë¦­ íƒ€ì… ì •ë³´ëŠ” ëŸ°íƒ€ì„ì— ì‚¬ë¼ì§€ì§€ë§Œ, Kotlinì˜ `inline` + `reified` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ë©´ ì»´íŒŒì¼ëŸ¬ê°€ êµ¬ì²´ì  íƒ€ì…ì„ ì¸ë¼ì¸í•˜ì—¬ ëŸ°íƒ€ì„ì—ì„œë„ íƒ€ì… ì •ë³´ë¥¼ í™œìš©í•  ìˆ˜ ìˆë‹¤.
