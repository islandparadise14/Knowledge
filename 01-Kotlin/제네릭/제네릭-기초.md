---
tags: [kotlin, generics, type-parameter]
---

# ì œë„¤ë¦­ ê¸°ì´ˆ

## ğŸ’¡ í•µì‹¬ ê°œë…

**ì œë„¤ë¦­(Generics)**ì€ íƒ€ì…ì„ íŒŒë¼ë¯¸í„°í™”í•´ì„œ ì½”ë“œ ì¬ì‚¬ìš©ì„±ì„ ë†’ì´ê³  íƒ€ì… ì•ˆì „ì„±ì„ ë³´ì¥í•œë‹¤. `List<T>`, `Flow<T>` ê°™ì€ í˜•íƒœë¡œ ì‚¬ìš©í•œë‹¤.

## ğŸ“Œ ì™œ í•„ìš”í•œê°€?

ê°™ì€ ë¡œì§ì„ ì—¬ëŸ¬ íƒ€ì…ì— ì ìš©í•  ìˆ˜ ìˆë‹¤. ì»´íŒŒì¼ íƒ€ì„ì— íƒ€ì…ì„ ì²´í¬í•´ì„œ ëŸ°íƒ€ì„ ì—ëŸ¬ë¥¼ ë°©ì§€í•œë‹¤. ìºìŠ¤íŒ… ì—†ì´ íƒ€ì… ì•ˆì „í•˜ê²Œ ì‘ì—… ê°€ëŠ¥í•˜ë‹¤.

## ğŸ” ìì„¸íˆ

### ê¸°ë³¸ ì‚¬ìš©ë²•

```kotlin
// ì œë„¤ë¦­ í´ë˜ìŠ¤
class Box<T>(val value: T)

val intBox = Box(123)  // Box<Int>
val stringBox = Box("Hello")  // Box<String>

// ì œë„¤ë¦­ í•¨ìˆ˜
fun <T> singletonList(item: T): List<T> {
    return listOf(item)
}

singletonList(1)  // List<Int>
singletonList("text")  // List<String>

// ì œë„¤ë¦­ ì¸í„°í˜ì´ìŠ¤
interface Repository<T> {
    suspend fun getAll(): List<T>
    suspend fun getById(id: String): T?
}
```

### íƒ€ì… ì œì•½ (Type Constraints)

```kotlin
// ìƒí•œ ì œì•½
fun <T : Number> sum(a: T, b: T): Double {
    return a.toDouble() + b.toDouble()
}

sum(1, 2)  // OK
sum(1.5, 2.3)  // OK
// sum("1", "2")  // ERROR

// ì—¬ëŸ¬ ìƒí•œ ì œì•½
fun <T> copy(from: T, to: T) where T : Cloneable, T : Comparable<T> {
    // TëŠ” Cloneableì´ë©´ì„œ Comparableì´ì–´ì•¼ í•¨
}

// nullable ìƒí•œ
fun <T : Any> nonNull(value: T) {
    // TëŠ” nullableì´ ì•„ë‹˜
}

fun <T : Any?> nullable(value: T) {
    // TëŠ” nullable ê°€ëŠ¥ (ê¸°ë³¸ê°’)
}
```

### ë³€ì„± (Variance)

**ê³µë³€ì„± (Covariance) - out**

```kotlin
// out T - Të¥¼ ë°˜í™˜ë§Œ í•  ìˆ˜ ìˆìŒ (ìƒì‚°ì)
interface Producer<out T> {
    fun produce(): T
    // fun consume(item: T)  // ERROR: in position
}

open class Animal
class Dog : Animal()

val dogProducer: Producer<Dog> = object : Producer<Dog> {
    override fun produce() = Dog()
}

// Dogì˜ ProducerëŠ” Animalì˜ Producerë¡œ ì·¨ê¸‰ ê°€ëŠ¥
val animalProducer: Producer<Animal> = dogProducer  // OK
```

**ë°˜ê³µë³€ì„± (Contravariance) - in**

```kotlin
// in T - Të¥¼ íŒŒë¼ë¯¸í„°ë¡œë§Œ ë°›ì„ ìˆ˜ ìˆìŒ (ì†Œë¹„ì)
interface Consumer<in T> {
    fun consume(item: T)
    // fun produce(): T  // ERROR: out position
}

val animalConsumer: Consumer<Animal> = object : Consumer<Animal> {
    override fun consume(item: Animal) { }
}

// Animalì˜ ConsumerëŠ” Dogì˜ Consumerë¡œ ì·¨ê¸‰ ê°€ëŠ¥
val dogConsumer: Consumer<Dog> = animalConsumer  // OK
```

**ë¬´ê³µë³€ì„± (Invariance)**

```kotlin
// ê¸°ë³¸ê°’ - ì½ê¸°/ì“°ê¸° ëª¨ë‘ ê°€ëŠ¥
interface MutableBox<T> {
    fun get(): T
    fun set(value: T)
}

// Animalê³¼ DogëŠ” ì„œë¡œ ëŒ€ì… ë¶ˆê°€
val animalBox: MutableBox<Animal> = ...
// val dogBox: MutableBox<Dog> = animalBox  // ERROR
```

### íƒ€ì… í”„ë¡œì ì…˜ (Type Projection)

```kotlin
// ì‚¬ìš© ì§€ì  ë³€ì„± (use-site variance)
fun copy(from: Array<out Any>, to: Array<in Any>) {
    for (i in from.indices) {
        to[i] = from[i]
    }
}

val ints: Array<Int> = arrayOf(1, 2, 3)
val any: Array<Any> = Array(3) { "" }
copy(ints, any)  // OK
```

### ìŠ¤íƒ€ í”„ë¡œì ì…˜ (Star Projection)

```kotlin
// * - íƒ€ì…ì„ ëª¨ë¥¼ ë•Œ
fun printList(list: List<*>) {
    for (item in list) {
        println(item)  // itemì€ Any?
    }
}

printList(listOf(1, 2, 3))
printList(listOf("a", "b", "c"))

// MutableList<*>ëŠ” MutableList<out Any?>ì™€ ìœ ì‚¬
// ì½ê¸°ë§Œ ê°€ëŠ¥, ì“°ê¸° ë¶ˆê°€
```

### ë™ì‘ ì›ë¦¬

**íƒ€ì… ì†Œê±° (Type Erasure)**

```kotlin
val stringList = listOf("a", "b")
val intList = listOf(1, 2)

// ëŸ°íƒ€ì„ì—ëŠ” íƒ€ì… ì •ë³´ê°€ ì‚¬ë¼ì§
println(stringList::class)  // class kotlin.collections.ArrayList
println(intList::class)  // class kotlin.collections.ArrayList

// íƒ€ì… ì²´í¬ ë¶ˆê°€
// if (list is List<String>) { }  // ERROR

// ìŠ¤íƒ€ í”„ë¡œì ì…˜ ì‚¬ìš©
if (list is List<*>) { }  // OK
```

**reified íƒ€ì… íŒŒë¼ë¯¸í„°**

ì¼ë°˜ ì œë„¤ë¦­ì€ íƒ€ì… ì†Œê±°ë¡œ ëŸ°íƒ€ì„ì— íƒ€ì… ì •ë³´ê°€ ì‚¬ë¼ì§€ì§€ë§Œ, `reified`ëŠ” `inline` í•¨ìˆ˜ì™€ í•¨ê»˜ ì‚¬ìš©í•´ì„œ ëŸ°íƒ€ì„ì—ë„ íƒ€ì… ì •ë³´ë¥¼ ìœ ì§€í•œë‹¤. ì»´íŒŒì¼ëŸ¬ê°€ í˜¸ì¶œ ì§€ì ì— í•¨ìˆ˜ ë³¸ë¬¸ì„ ì¸ë¼ì´ë‹í•˜ë©´ì„œ ì‹¤ì œ íƒ€ì…ìœ¼ë¡œ ì¹˜í™˜í•˜ê¸° ë•Œë¬¸ì— ê°€ëŠ¥í•˜ë‹¤.

```kotlin
// ì¼ë°˜ ì œë„¤ë¦­ - ëŸ°íƒ€ì„ì— íƒ€ì… ì •ë³´ ì—†ìŒ
fun <T> checkType(value: Any) {
    // if (value is T) { }  // ERROR: Cannot check for erased type
    // T::class               // ERROR: Cannot use 'T' as reified type parameter
}

// reified - ëŸ°íƒ€ì„ì— íƒ€ì… ì •ë³´ ìœ ì§€
inline fun <reified T> isInstance(value: Any): Boolean {
    return value is T  // OK! íƒ€ì… ì²´í¬ ê°€ëŠ¥
}

isInstance<String>("text")  // true
isInstance<Int>("text")     // false
```

**reifiedë¡œ í•  ìˆ˜ ìˆëŠ” ê²ƒë“¤:**

```kotlin
inline fun <reified T> reifiedExample() {
    // 1. íƒ€ì… ì²´í¬ (is)
    val isString = "hello" is T

    // 2. í´ë˜ìŠ¤ ë ˆí¼ëŸ°ìŠ¤
    val clazz: KClass<T> = T::class
    val javaClazz: Class<T> = T::class.java

    // 3. ë‹¤ë¥¸ reified í•¨ìˆ˜ì˜ íƒ€ì… ì¸ìë¡œ ì „ë‹¬
    val result = Gson().fromJson<T>(json, T::class.java)
}
```

**ì œì•½ ì‚¬í•­:**

```kotlin
// 1. ë°˜ë“œì‹œ inline í•¨ìˆ˜ì—ì„œë§Œ ì‚¬ìš©
// fun <reified T> notInline() { }  // ERROR: Only inline functions can have reified type parameters

// 2. í´ë˜ìŠ¤ë‚˜ í”„ë¡œí¼í‹°ì˜ íƒ€ì… íŒŒë¼ë¯¸í„°ì—ëŠ” ì‚¬ìš© ë¶ˆê°€
// class Box<reified T>  // ERROR

// 3. reified íƒ€ì…ìœ¼ë¡œ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ë¶ˆê°€
inline fun <reified T> create(): T {
    // return T()  // ERROR: Cannot create instance of type parameter
}
```

**Android ì‹¤ì „ í™œìš©:**

```kotlin
// Activity ì „í™˜
inline fun <reified T : Activity> Context.startActivity(
    configIntent: Intent.() -> Unit = {}
) {
    startActivity(Intent(this, T::class.java).apply(configIntent))
}

startActivity<DetailActivity> {
    putExtra("id", userId)
}

// Fragment ì¸ìì—ì„œ Parcelable êº¼ë‚´ê¸°
inline fun <reified T : Parcelable> Fragment.argument(key: String): Lazy<T> =
    lazy { requireArguments().getParcelable(key, T::class.java)!! }

// Gson ì—­ì§ë ¬í™”
inline fun <reified T> String.fromJson(): T =
    Gson().fromJson(this, object : TypeToken<T>() {}.type)

val users: List<User> = jsonString.fromJson()  // List<User> íƒ€ì… ì •ë³´ ìœ ì§€

// Timber / ë¡œê¹… íƒœê·¸ ìë™ ìƒì„±
inline fun <reified T> T.logTag(): String = T::class.java.simpleName
```

### ì£¼ì˜ì‚¬í•­

**1. ì œë„¤ë¦­ ë°°ì—´ ìƒì„± ë¶ˆê°€**

```kotlin
// ë¶ˆê°€
// val array = Array<T>(10)  // ERROR

// í•´ê²°ì±…
inline fun <reified T> createArray(size: Int): Array<T> {
    return Array(size) { TODO() }
}

// ë˜ëŠ”
val array = arrayOfNulls<T>(10)
```

**2. íƒ€ì… íŒŒë¼ë¯¸í„°ì˜ ìƒí•œì€ nullable**

```kotlin
fun <T> process(value: T) {
    // TëŠ” Any?ì´ë¯€ë¡œ null ê°€ëŠ¥
    value?.let { /* ... */ }
}

// Non-null ê°•ì œ
fun <T : Any> processNonNull(value: T) {
    // TëŠ” Anyì´ë¯€ë¡œ null ë¶ˆê°€
}
```

**3. ë³€ì„± ê·œì¹™**

```kotlin
// out - ë°˜í™˜ ìœ„ì¹˜ì—ë§Œ
interface Producer<out T> {
    fun produce(): T  // OK
    // fun consume(item: T)  // ERROR
}

// in - íŒŒë¼ë¯¸í„° ìœ„ì¹˜ì—ë§Œ
interface Consumer<in T> {
    fun consume(item: T)  // OK
    // fun produce(): T  // ERROR
}
```

## ğŸ’» ì‹¤ì „ ì˜ˆì œ

### Repository íŒ¨í„´

```kotlin
interface Repository<T> {
    suspend fun getAll(): List<T>
    suspend fun getById(id: String): T?
    suspend fun insert(item: T)
    suspend fun update(item: T)
    suspend fun delete(id: String)
}

class UserRepository : Repository<User> {
    override suspend fun getAll(): List<User> = api.getUsers()
    override suspend fun getById(id: String): User? = api.getUser(id)
    override suspend fun insert(item: User) = api.createUser(item)
    override suspend fun update(item: User) = api.updateUser(item)
    override suspend fun delete(id: String) = api.deleteUser(id)
}
```

### Result ë˜í¼

```kotlin
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    data class Error(val exception: Throwable) : Result<Nothing>()
    object Loading : Result<Nothing>()
    
    fun <R> map(transform: (T) -> R): Result<R> {
        return when (this) {
            is Success -> Success(transform(data))
            is Error -> this
            Loading -> Loading
        }
    }
}

// ì‚¬ìš©
val userResult: Result<User> = repository.getUser(id)
val nameResult: Result<String> = userResult.map { it.name }
```

### ViewModel ê¸°ë³¸ í´ë˜ìŠ¤

```kotlin
abstract class BaseViewModel<T> : ViewModel() {
    protected val _uiState = MutableStateFlow<UiState<T>>(UiState.Initial)
    val uiState: StateFlow<UiState<T>> = _uiState.asStateFlow()
    
    sealed class UiState<out T> {
        object Initial : UiState<Nothing>()
        object Loading : UiState<Nothing>()
        data class Success<T>(val data: T) : UiState<T>()
        data class Error(val message: String) : UiState<Nothing>()
    }
}

class UserViewModel : BaseViewModel<User>() {
    fun loadUser(id: String) {
        viewModelScope.launch {
            _uiState.value = UiState.Loading
            try {
                val user = repository.getUser(id)
                _uiState.value = UiState.Success(user)
            } catch (e: Exception) {
                _uiState.value = UiState.Error(e.message ?: "Unknown")
            }
        }
    }
}
```

### Type-safe Builder

```kotlin
@DslMarker
annotation class HtmlDsl

@HtmlDsl
class HTML {
    private val children = mutableListOf<Tag>()
    
    fun <T : Tag> tag(tag: T, init: T.() -> Unit): T {
        tag.init()
        children.add(tag)
        return tag
    }
}

@HtmlDsl
abstract class Tag(val name: String) {
    private val children = mutableListOf<Tag>()
    
    fun <T : Tag> tag(tag: T, init: T.() -> Unit): T {
        tag.init()
        children.add(tag)
        return tag
    }
}

class Body : Tag("body")
class Head : Tag("head")

// ì‚¬ìš©
fun html(init: HTML.() -> Unit): HTML {
    return HTML().apply(init)
}

val page = html {
    tag(Head()) { }
    tag(Body()) { }
}
```

## ğŸ”— ê´€ë ¨ ê°œë…

- [[01-Kotlin/ì œë„¤ë¦­/ë³€ì„±-in-out]]
- [[01-Kotlin/ì œë„¤ë¦­/Reified]]
- [[01-Kotlin/í•¨ìˆ˜í˜•-í”„ë¡œê·¸ë˜ë°/ê³ ì°¨í•¨ìˆ˜]]

## ğŸ“š ë” ë³´ê¸°

- [Kotlin Docs - Generics](https://kotlinlang.org/docs/generics.html)

---

**í•µì‹¬ ìš”ì•½:** ì œë„¤ë¦­ìœ¼ë¡œ íƒ€ì… ì•ˆì „ì„± ë³´ì¥. out(ìƒì‚°), in(ì†Œë¹„). íƒ€ì… ì†Œê±° ì£¼ì˜. reifiedë¡œ íƒ€ì… ì²´í¬.
